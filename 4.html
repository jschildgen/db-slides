<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Datenbanken - Kapitel 4 - SQL</title>

        <link rel="stylesheet" href="reveal.js/dist/reset.css">
		<link rel="stylesheet" href="reveal.js/dist/reveal.css">

        <link rel="stylesheet" href="src/slides.css">
        <link rel="stylesheet" href="src/sql.css">

		<link rel="stylesheet" href="src/layout.css">
        <link rel="stylesheet" href="lib/joint.min.css" />
        <link rel="stylesheet" href="src/erd.css" />
        <link rel="stylesheet" href="src/poll.css" />

		<!-- Theme used for syntax highlighting of code -->
		<script>
			if(window.location.search.match( /print-pdf/gi )) {
				document.getElementsByTagName("head")[0].innerHTML += '<link rel="stylesheet" href="src/routeros.css">';
			} else {
				document.getElementsByTagName("head")[0].innerHTML += '<link rel="stylesheet" href="src/rainbow.css">';
			}
		</script>

        <!--<script defer src="lib/fontawesome.all.min.js"/>-->
        <link href="lib/fontawesome.all.min.css" rel="stylesheet">
        <style> .reveal i.fa { font-family:FontAwesome; font-style: normal; } </style>
	</head>
	<body>
		<div class="reveal">
            <div id="header"></div>
            <div id="footer"></div>
			<div class="slides">
                    <section>
                        <h4 style="text-align:center"><b>Prof. Dr.-Ing. Johannes Schildgen</b><br>
                        <a href="mailto:johannes.schildgen@oth-regensburg.de">johannes.schildgen@oth-regensburg.de</a></h4>
                        <h1>Datenbanken</h1>
                        <h3>Kapitel 4: SQL</h3>
                        <h4 style="text-align:center">&nbsp;</h4>
                        <img src="img/ccby.png" height="60px" style="position: absolute; left:0px; border:0; bottom:-160px;">
                        <img src="img/oth.png" height="60px" style="position: absolute; right:0px; border:0; bottom:-160px; box-shadow:none">
                    </section>
                        <section>
                            <h2>SQL...</h2>
                            <div class="trackinfo"><i class="fas fa-headphones"></i> 33, 36</div>
                            <ul class="small">
                                <li>... ist der Nachfolger von SEQUEL (Structured English Query Language),</li>
                                <li>... wurde in den 1970er-Jahren entworfen,</li>
                                <li>... ist ein eigenständiger Begriff,</li>
                                <li>... wird manchmal als Abkürzung für Structured Query Language gesehen,</li>
                                <li>... ist eine standardisierte Anfragesprache für strukturierte Datenbanken,</li>
                                <li>... ist größtenteils unabhängig vom verwendeten relationalen DBMS (RDBMS).</li>
                            </ul>
                            <aside class="notes">SQL ist eine leicht zu erlernende aber trotzdem sehr mächtige Anfragesprache für alle Aufgaben bei der Arbeit mit relationalen Datenbanken. Gelegentliche Benutzer können schnell simple Abfragen schreiben, erfahrene Benutzer können sich fortgeschrittenen Sprachkonstrukten bedienen. Der SQL-Standard ist ein ISO-Standard und wird ständig weiterentwickelt (SQL92, ..., SQL:2016). Dadurch, dass die Sprache standardisiert ist, verwenden alle populären relationalen Datenbankmanagementsysteme als Anfragesprache SQL. Dies macht Anwendungen portabel (Wechsel zu anderem DBMS) und es reduziert den Lernaufwand für die Anwender.</aside>
                        </section>
                        
                        <section>
                            <h2>Populäre RDBMS</h2>
                            <div class="trackinfo"><i class="fas fa-headphones"></i> 34-35</div>
                            <p class="small">Quelle: db-engines.com/de/ranking</p>
                            <ol>
                                <li>Oracle</li>
                                <li>MySQL</li>
                                <li>Microsoft SQL Server</li>
                                <li>PostgreSQL <span class="fragment small" data-fragment-index="2">&leftarrow; verwenden wir im Rahmen dieser Vorlesung</span></li>
                                <li>IBM DB2</li>
                                <li>SQLite</li>
                                <li>MariaDB</li>
                            </ol>
                            <div class="poll fragment fade-in-then-out" style="bottom:-100px" data-fragment-index="1">
                                <h1>Haben Sie schon einmal mit einem RDBMS gearbeitet?</h1>
                                    <ul>
                                        <li>Oracle</li>
                                        <li>MySQL / MariaDB</li>
                                        <li>Microsoft SQL Server</li>
                                        <li>PostgreSQL</li>
                                        <li>IBM DB2</li>
                                        <li>SQLite</li>
                                        <li>Mit einem anderen</li>
                                        <li>Mit keinem</li>
                                    </ul>
                                <h2>https://fraage.de</h2>
                            </div>
                            <aside class="notes">Die hier dargestellte Liste ist geordnet nach der Popularität der relationalen DBMS. Oracle, SQL Server und DB2 sind kommerzielle Systeme, MySQL, PostgreSQL, SQLite und MariaDB sind open source. MySQL wurde 2010 von Oracle aufgekauft und es hat sich ein zu MySQL kompatibler Fork MariaDB entwickelt. Alle hier dargestellten Systeme außer SQLite laufen als Serverprozess, sodass sich Anwendungen mit dem Datenbank-Server verbinden können, um Anfragen auf diesen zu stellen.</aside>
                        </section>
                        <section>
                            <h2>PostgreSQL</h2>
                            <ul style="width:18cm">
                                <li>&quot;The world's most advanced open source database&quot;</li>
                                <li>Einfach zu installieren, viele Features, Transaktionen, gute Dokumentation, ...</li>
                                <li>SQL-Clients: psql, pgAdmin3, pgAdmin4</li>
                            </ul>
                            <img src="img/4/postgres.png" class="noborder" style="position: absolute; width: 5cm; right: 1cm; top: 3cm">
                            <aside class="notes">psql ist ein Konsolen-Client, um z. B. in einer SSH-Shell direkt SQL-Befehle an eine PostgreSQL-Datenbank zu schicken und das Ergebnis zu betrachten. pgAdmin ist ein GUI-Client für verschiedene Betriebssysteme.</aside>
                        </section>
                        <section>
                            <h2>DBeaver</h2>
                            
                            <img src="img/4/dbeaver.png" alt="DBeaver" class="stretch noborder">
                            <aside class="notes">Wir verwenden im Rahmen dieser Vorlesung den kostenlosen universellen SQL-Client DBeaver.</aside>
                        </section>
                        
                        <section>
                                <h2>Sprachkomponenten</h2>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 37</div>
                                <h4>DDL: Data Definition Language</h4>
                                <ul class="small">
                                    <li>Definition des Datenbankschemas (Metadaten)</li>
                                    <li><code>CREATE TABLE</code>, <code>DROP TABLE</code>, <code>ALTER TABLE</code>, <code>CREATE VIEW</code>, ...</li>
                                </ul>
                                <p/>
                                <h4 class="fragment" data-fragment-index="1">DML: Data Manipulation Language</h4>
                                <ul class="fragment small" data-fragment-index="1">
                                    <li>Einfügen, Ändern, Löschen und Lesen von Daten</li>
                                    <li><code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>SELECT</code>, ...</li>
                                </ul>
                                <p/>
                                <h4 class="fragment" data-fragment-index="2">DCL: Data Control Language</h4>
                                <ul class="fragment small" data-fragment-index="2">
                                    <li>Benutzer-, Rollen- und Rechteverwaltung</li>
                                    <li><code>CREATE USER</code>, <code>CREATE ROLE</code>, <code>GRANT</code>, <code>REVOKE</code>, ...</li>
                                </ul>
                                <div class="poll fragment" style="bottom:-50px">
                                    <h1>Mit welcher Art Kommando können Sie Daten von einer Tabelle eine andere kopieren?</h1>
                                        <ul>
                                            <li>DDL</li>
                                            <li data-poll="correct">DML</li>
                                            <li>DCL</li>
                                        </ul>
                                    <h2>https://fraage.de</h2>
                                </div>
                                <aside class="notes">SELECT gehört zur DML, da die Daten für den Zeitpunkt der Anfragestellung manipuliert werden. Der Benutzer sieht eine modifizierte Form der Daten. Natürlich wird diese Änderung anders als z. B. bei UPDATE nicht persistent in der Datenbank gespeichert. </aside>
                            </section> 

                            <section>
                                <h2>SQL ausprobieren</h2>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 38</div>
                                <h4>SQL Island</h4>
                                <img src="img/4/sql_island.png" class="noborder" style="position: absolute; width: 2.5cm; right: 1cm; top: 1mm">
                                <ul>
                                    <li>Lernspiel, welches keine Vorkenntnisse voraussetzt.</li>
                                    <li><a href="http://www.sql-island.de" target="_blank">sql-island.de</a></li>
                                </ul>
                                <p></p>
                                <h4>SQL Fiddle, DB Fiddle, Rextester</h4>
                                <ul>
                                    <li>Tabellen erstellen, befüllen und abfragen im Browser</li>
                                    <li><a href="http://sqlfiddle.com" target="_blank">sqlfiddle.com</a>, <a href="https://dbfiddle.uk" target="_blank">dbfiddle.uk</a>, <a href="http://rextester.com/" target="_blank">rextester.com</a></li>
                                    
                                </ul>
                                <aside class="notes">Alle hier dargestellten Anwendungen sind SQL-Spielwiesen, die ohne Anmeldung direkt im Browser verwendet werden können. Das Lernspiel SQL Island hat eine Handlung, man muss von einer Insel entkommen. Die Tabellen dazu sind bereits angelegt und mit Daten gefüllt. Bei den anderen Tools muss man selbst Tabellen anlegen und befüllen. Man hat verschiedene DBMS zur Auswahl.</aside>
                            </section>
                            <section>
                                <h2>Sprachelemente</h2>
                                <pre><code class="sql" data-trim contenteditable>SELECT email FROM kunden WHERE name = 'Ute';</code></pre>
                                <h4 style="font-size: 90%;">SQL-Schlüsselworte (Keywords)</h4>
                                <ul class="small">
                                    <li style="margin-top: -3mm;">Groß-/Kleinschreibung egal</li>
                                    <li>SELECT, FROM, WHERE, GROUP, BY, INSERT, CREATE, USER, AS, ...</li>
                                </ul>
                                
                                <h4 style="font-size: 90%; margin-top: 2mm;">Identifikatoren (Namen von Tabellen, Spalten, etc.)</h4>
                                <ul class="small">
                                    <li style="margin-top: -3mm;">Reguläre: case-insensitive; Begrenzte: case-sensitive</li>
                                    <li>Beispiele: email, kunden, name, "user", "Kunden", "A B"</li>
                                </ul>
                                
                                <h4 style="font-size: 90%; margin-top: 2mm;">Literale (Werte eines Datentyps)</h4>
                                <ul class="small">
                                    <li style="margin-top: -3mm;">Groß-/Kleinschreibung nicht egal!</li>
                                    <li>Beispiele: 'Ute', 'Otto''s Imbiss', 5, 2.99, NULL, '2020-11-18'</li>
                                </ul>
                                <div class="poll fragment" style="bottom:-80px">
                                    <h1>Was wäre, wenn in der Anfrage 'Ute' nicht in Hochkommas stünde?</h1>
                                        <ul>
                                            <li>Das ginge trotzdem</li>
                                            <li>Das wäre kein wohlgeformtes SQL</li>
                                            <li>Dann wäre damit die Variable Ute gemeint</li>
                                            <li data-poll="correct">Dann wäre damit die Spalte Ute gemeint</li>
                                        </ul>
                                    <h2>https://fraage.de</h2>
                                </div>
                                <aside class="notes">Merkregel: Bei allem, was man in Anführungszeichen schreibt, kommt es auf die korrekte Groß-/Kleinschreibung an. Bei regulären Identifikatoren sind reservierte SQL-Keywords und Sonderzeichen (außer _) verboten, bei begrenzten Identifikatoren ist dies erlaubt. In MySQL werden begrenzte Identifikatoren in `Apostrophe` geschrieben, bei PostgreSQL in &quot;Anführungszeichen&quot;.</aside>
                            </section>

                            <section>
                                <h2>Kommentare</h2>
                                <pre><code class="sql" data-trim contenteditable>SELECT * FROM t -- Ein Doppelminus leitet einen Kommentar ein</code></pre>

                                <pre><code class="sql" data-trim contenteditable>SELECT * FROM t
--WHERE x = 5</code></pre>

<pre><code class="sql" data-trim contenteditable>SELECT kundennummer /*, email*/ FROM kunden</code></pre>

                                 <aside class="notes">Alles, was in einer Zeile auf ein <code>--</code> folgt, ist ein Kommentar und gehört nicht mehr zur Anfrage. Dies ist auch praktisch, um vorübergehend gewisse Teile einer Anfrage wegzulassen und später wieder zu entkommentieren. Die Syntax <code>/* ... */</code> ermöglicht Kommentare innerhalb einer Zeile und Kommentare, die mehrere Zeilen umfassen.</aside>
                            </section>

                            <section>
                                <h2>DDL: CREATE, ALTER, DROP</h2>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 44</div>
                                <p>Anlegen, Verändern und Entfernen von <em>Datenbankobjekten</em> (Tabellen, Sichten, Funktionen, ...)</p>
                                <pre style="width:95%"><code class="sql" data-trim contenteditable>CREATE TABLE personen (pid INT, name VARCHAR(500), geboren DATE);</code></pre>
                            
                                <h4>CREATE TABLE</h4>
                                <ul class="small">
                                    <li>Name der zu erstellenden Tabelle</li>
                                    <li>Spalten in Klammern, Komma-getrennt</li>
                                    <li>Zu jeder Spalte: Name, Datentyp, evtl. Spaltenoptionen</li>
                                </ul>

                                <aside class="notes">Das Semikolon am Ende einer Anfrage lassen wir ab sofort einfach weg. Es ist lediglich wichtig, wenn man in einem SQL-Editor mehrere Anfragen formuliert, um diese voneinander zu treffen.</aside>
                            </section>
                            <section>
                                <h2>Datentypen</h2>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 39-41</div>
                                <table class="small">
                                    <thead><tr><th>Datentyp</th><th>Alias</th><th>Beschreibung</th><th>Beispiel</th></tr></thead>
                                    <tbody>
                                        <tr><td>INTEGER</td><td>INT</td><td>Ganze Zahl</td><td>-217</td></tr>
                                        <tr><td>DECIMAL(p,s)</td><td>NUMERIC</td><td>Zahl mit p Stellen, davon s nach dem Dezimalpunkt</td><td>DECIMAL(5,2) -149.99</td></tr>
                                        <tr><td>DOUBLE</td><td>REAL</td><td>Fließkommazahl (nicht exakt)</td><td>-15.127E-2</td></tr>
                                        <tr><td>CHARACTER(l)</td><td>CHAR</td><td>Zeichenkette mit fixer Länge l</td><td>CHAR(3) 'AB '</td></tr>
                                        <tr><td>CHARACTER VARYING(l)</td><td>VARCHAR</td><td>Zeichenkette mit max. Länge l</td><td>VARCHAR(3) 'AB'</td></tr>
                                        <tr><td>DATE</td><td></td><td>Datum (Jahr, Monat, Tag)</td><td>'2020-11-18'</td></tr>
                                        <tr><td>TIMESTAMP</td><td></td><td>Zeitstempel (Datum und Uhrzeit)</td><td>'2020-11-18 14:37:52.681'</td></tr>
                                    </tbody>
                                </table>
                                <aside class="notes">Diese Liste ist nicht vollständig. Es gibt noch viele weitere Datentypen in SQL und jedes DBMS bringt weitere Typen mit. Die hier dargestellte Fließkommazahl ist $-15$,$127\cdot 10^{-2}$.</aside>
                            </section>
                            <section>
                                <h3>CREATE TABLE - Spaltenoptionen</h3>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 45, 47</div>
                                <pre><code class="sql" data-trim contenteditable>CREATE TABLE kunden (
 kundennummer INT PRIMARY KEY, name VARCHAR(100) NOT NULL, 
 email VARCHAR(500) CHECK (email LIKE '%@%') UNIQUE, 
 passwort CHAR(32), land VARCHAR(100) DEFAULT 'Deutschland', 
 geworben_von INT REFERENCES kunden(kundennummer));</code></pre>

                                <h4>Constraints (Integritätsbedingungen):</h4>
                                <ul class="small">
                                    <li>PRIMARY KEY: Primärschlüssel</li>
                                    <li>NOT NULL: Verbot von NULL-Werten</li>
                                    <li>CHECK: Bedingung für akzeptierte Werte</li>
                                    <li>UNIQUE: Eindeutigkeit</li>
                                    <li>DEFAULT: Standardwert</li>
                                    <li>REFERENCES: Fremdschlüsselreferenz</li>
                                </ul>
                                <aside class="notes">Hinter den Namen und Datentypen einer Spalte können Spaltenconstraints geschrieben werden. Dies sind Integritätsbedingungen, die stets erfüllt sein müssen. Beispielsweise verbietet ein UNIQUE-Constraint, dass in der Spalte in zwei Zeilen der gleiche Wert vorkommt. Das im Beispiel verwendete CHECK-Constraint garantiert, dass in jeder E-Mail-Adresse ein @-Zeichen vorkommen muss.</aside>
                            </section>

                            <section>
                                    <h3>NULL / NOT NULL</h3>
                                    <h4>NULL (Standard)</h4>
                                    <pre><code class="sql" data-trim contenteditable>CREATE TABLE kunden (/* ... */, name VARCHAR(100) NULL)</code></pre>
                                    <p>NULL-Werte sind in der Spalte erlaubt.</p>
    
                                    <h4>NOT NULL</h4>
                                    <pre><code class="sql" data-trim contenteditable>CREATE TABLE kunden (/* ... */, name VARCHAR(100) NOT NULL)</code></pre>
                                    <p>NULL-Werte sind in der Spalte verboten.</p>
                                    <aside class="notes">In den meisten DBMS ist <code>NULL</code> die Standard-Eigenschaft von Spalten, das heißt, man darf NULL-Werte in die Spalte eintragen. Will man dies verhindert, deklariert man die Spalte als <code>NOT NULL</code>. Im hier gezeigten unteren Beispiel ist das Attribut &quot;Name&quot; also ein Pflichtfeld.</aside>
                            </section>

                            <section>
                                <h3>UNIQUE-Constraint</h3>
                                <pre><code class="sql" data-trim contenteditable>CREATE TABLE kunden (/* ... */, email VARCHAR(500) UNIQUE)</code></pre>
                                <p class="small">oder:</p>
                                <pre><code class="sql" data-trim contenteditable>CREATE TABLE kunden (/* .... */ email VARCHAR(500), 
                     UNIQUE(email))</code></pre>
                                
                                <div class="poll fragment" style="bottom:-350px">
                                    <h1>Welchen Vorteil hat die untere Notationsform?</h1>
                                        <ul>
                                            <li>Keinen</li>
                                            <li>Besser lesbar</li>
                                            <li data-poll="correct">UNIQUE-Constraint über eine Kombination mehrerer Spalten möglich</li>
                                            <li>Spart Schreibarbeit</li>
                                        </ul>
                                    <h2>https://fraage.de</h2>
                                </div>
                                <aside class="notes">Spezifiziert man hinter einer Spalte die Eigenschaft <code>UNIQUE</code>, darf es in dieser Spalte keine doppelten Werte gegen. In unserer Kundentabelle dürfen also keine zwei Kunden die gleiche E-Mail-Adresse haben. Die untere Notation ist nötig, wenn das UNIQUE-Constraint aus mehreren Spalten besteht, also wenn die Kombination aus mehreren Spaltenwerten eindeutig sein soll. Anders als bei Primärschlüsseln (in einer Tabelle darf höchstens einen geben), können auf einer Tabelle beliebig viele UNIQUE-Constraints definiert werden.</aside>
                            </section>

                            <section>
                                <h3>Primärschlüssel-Constraint</h3>
                                <div style="position: absolute; top: 20px; right:5px; font-size:170px"><i class="fas fa-key green"></i></div>
                                <pre style="width: 20cm; left:-14mm;"><code class="sql" data-trim contenteditable>CREATE TABLE kunden (kundennummer INT PRIMARY KEY, ...)</code></pre>
                                <p class="small">oder:</p>
                                <pre><code class="sql" data-trim contenteditable>CREATE TABLE kunden (kundennummer INT, ..., 
                     PRIMARY KEY(kundennummer))</code></pre>
                                
                            <p>Primärschlüssel sind UNIQUE und NOT NULL.</p>
                            <aside class="notes">Wenn der Primärschlüssel nur aus einer Spalte besteht, kann man <code>PRIMARY KEY</code> direkt hinter die Spalte schreiben. Primärschlüssel sind UNIQUE, d. h. es gibt keine Duplikate in der Tabelle in diesen Spalten. Außerdem sind Primärschlüsselattribute alle NOT NULL, d. h. in ihnen dürfen keine NULL-Werte vorkommen.</aside>
                                
                            </section>

                            <section>
                                <h3>Fremdschlüssel-Constraints</h3>
                                <pre><code class="sql" data-trim contenteditable>CREATE TABLE kunden (/* ... */,
 geworben_von INT REFERENCES kunden(kundennummer));</code></pre>
                            <p class="small">oder:</p>
                            <pre><code class="sql" data-trim contenteditable>CREATE TABLE kunden (/* ... */,
 geworben_von INT,
 FOREIGN KEY(geworben_von) REFERENCES kunden(kundennummer));</code></pre>
                            <aside class="notes">Besteht der Fremdschlüssel nur aus einer Spalte, kann <code>REFERENCES tabelle(spalte)</code> direkt hinter die Spalte geschrieben werden. Ansonsten muss die unten stehende <code>FOREIGN KEY</code>-Schreibweise verwendet werden.</aside>
                            </section>

                            <section>
                                <h3>Zusammengesetzte Primär-/Fremdschlüssel</h3>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 46, 48</div>
                                <pre><code class="sql" data-trim contenteditable data-line-numbers="6">CREATE TABLE bewertungen (
 kundennummer INT REFERENCES kunden(kundennummer),
 produktnummer INT REFERENCES produkte(produktnummer),
 sterne INT DEFAULT 5 CHECK(sterne BETWEEN 1 AND 5),
 bewertungstext VARCHAR(100000),
 PRIMARY KEY(kundennummer, produktnummer));</code></pre>
 <pre class="fragment"><code class="sql" data-trim contenteditable data-line-numbers="5-6">CREATE TABLE bewertungslikes (
 liker INT REFERENCES kunden(kundennummer),
 kundennummer INT, produktnummer INT,
 PRIMARY KEY(liker, kundennummer, produktnummer),
 FOREIGN KEY(kundennummer, produktnummer) 
  REFERENCES bewertungen(kundennummer, produktnummer));</code></pre>
                            <aside class="notes">Wenn der Primärschlüssel zusammengesetzt ist aus mehreren Spalten, ist es nicht mehr möglich, einfach PRIMARY KEY in die Spaltenoptionen zu schreiben. Stattdessen muss das PRIMARY-KEY-Constraint unten drunter geschrieben werden. Der Grund dafür ist, dass es nicht mehrere Primärschlüssel geben kann. Eine Tabelle hat immer nur einen Primärschlüssel, dieser kann jedoch zusammengesetzt sein aus mehreren Spalten. Das gleiche gilt für FOREIGN-KEY-Constraints für zusammengesetzte Fremdschlüssel.</aside>
                            </section>
                            
                            <section data-hide-from="2V">
                                <h2>Referentielle Aktionen</h2>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 49</div>
                                <pre style="width: 95%;"><code class="sql" data-trim contenteditable data-line-numbers="5">CREATE TABLE produkte (
 produktnummer INT PRIMARY KEY, 
 bezeichnung VARCHAR(100) NOT NULL, preis DECIMAL(9,2), 
 hersteller VARCHAR(50) REFERENCES hersteller(firma) 
                        ON DELETE SET NULL ON UPDATE CASCADE);
                                </code></pre>
                                <p class="small">Was soll passieren, wenn ein Hersteller gelöscht wird, von dem es noch Produkte gibt? (Analog dazu: Was passiert, wenn man ihn umbenennt? - <code>ON UPDATE</code>)</p>
                                <ul class="small">
                                    <li class="fragment"><b><code>ON DELETE CASCADE</code></b>: Alle Produkte auch löschen</li>
                                    <li class="fragment"><b><code>ON DELETE SET NULL / SET DEFAULT</code></b>: NULL / Default-Wert setzen</li>
                                    <li class="fragment"><b><code>ON DELETE RESTRICT</code></b>: Löschen verbieten</li>
                                    <li class="fragment"><b><code>ON DELETE NO ACTION</code></b> (Standardverhalten): erst mal abwarten</li>
                                </ul>
                                <div class="poll fragment" style="bottom:-120px">
                                    <h1>Was wird hier beim Löschen auf NULL gesetzt?</h1>
                                        <ul>
                                            <li data-poll="correct">produkte.hersteller</li>
                                            <li>hersteller.firma</li>
                                            <li>hersteller.land</li>
                                            <li>gar nichts</li>
                                        </ul>
                                    <h2>https://fraage.de</h2>
                                </div>
                                <aside class="notes">Unter einer Aktion versteht man den Dann-Teil einer Wenn-Dann-Regel. Wenn man einen Hersteller löscht, dann... Im oben gezeigten Beispiel wird in einem solchen Fall wegen <code>ON DELETE SET NULL</code> der Wert der Hersteller-Spalte in der Produkte-Tabelle auf NULL gesetzt. Das <code>ON UPDATE CASCADE</code> sorgt dafür, dass bei einer Umbenennung im Primärschlüsselattribut des Herstellers (Firma) diese Umbenennung auch bei den Produkten dieses Herstellers erfolgt.</aside>
                            </section>
                            <section data-hide-from="2V">
                                <h3>ON DELETE NO ACTION</h3>
                                <p class="small">Fachbereich (<u>FBName</u>)<br>
                                                 Studierende (<u>MatrNr</u>, Name, FBName)<br>
                                                 Professoren (<u>ProfNr</u>, Name, FBName)<br>
                                                 Prüfungen (<u>MatrNr, ProfNr, Fach, Versuch</u>, Note)</p>
                                <p class="small">&nbsp;</p>
                                <p class="small">Studierende(FBName) REFERENCES Fachbereich(FBName) ON DELETE CASCADE<br>
                                                 Professoren(FBName) REFERENCES Fachbereich(FBName) ON DELETE CASCADE<br>
                                                 Prüfungen(MatrNr) REFERENCES Studierende(MatrNr) ON DELETE CASCADE<br>
                                                 Prüfungen(ProfNr) REFERENCES Professoren(MatrNr)</p>

                                <p class="small">Fachbereich wird gelöscht &Rightarrow; alle Studierenden in diesem werden gelöscht &Rightarrow; Die Prüfungen der Studierenden werden gelöscht. Professoren werden gelöscht. OK!</p>

                                <div style="position:absolute; left: 560px; top: 80px; height: 240px; overflow:hidden;">
                                        <div class="erd" style="width: 450px;">
                                                [[
                                                { _e: "Fachbereich", pos: [130, 15] },
                                                { _e: "Studierender", pos: [5, 90] },
                                                { _e: "Professor", pos: [260, 90] },
                                                { _e: "Prüfung", pos: [130, 170], options:["weak"] },
                                                 
                                                ],
                                                [ {_r: "hat", _e:["Fachbereich", "Studierender"], card:["1","N"], pos: [40, 0]},
                                                  {_r: "hat", _e:["Fachbereich", "Professor"], card:["1","N"], pos: [300, 0]},
                                                  {_r: "legt ab", _e:["Studierender", "Prüfung"], card:["1","N"], pos: [40, 155]},
                                                  {_r: "prüft", _e:["Professor", "Prüfung"], card:["1","N"], pos: [300, 155]},
                                                ]]
                                        </div></div>
                                    <aside class="notes">Würde statt NO ACTION hier RESTRICT verwendet werden, kann es passieren, dass zuerst versucht wird, Professoren des Fachbereichs zu löschen. Dies wird jedoch abgelehnt, weil noch Prüfungen von diesem existieren. Würden zuerst die Studenten gelöscht, funktioniert das Löschen des Fachbereichs. Da das Verhalten in dem Fall nicht deterministisch ist, spricht man hier von einem <em>unsicheren Schema</em>.</aside>
                            </section>

                            <section>
                                <h3>DEFAULT-Werte für Spalten</h3>
                                <pre><code class="sql" data-trim contenteditable>CREATE TABLE kunden (/* ... */,
                     land VARCHAR(100) DEFAULT 'Deutschland');</code></pre>
                                <p>Wird beim Einfügen in die Tabelle der Wert für eine Spalte nicht gesetzt, wird der DEFAULT-Wert dort eingetragen (standardmäßig NULL).</p>
                                <div class="poll fragment" style="bottom:-290px">
                                    <h1>Was ist wenn land keinen DEFAULT-Wert hat und NOT NULL ist und nun versucht wird, beim Einfügen kein Land zu setzen?</h1>
                                        <ul>
                                            <li>Land ist NULL</li>
                                            <li>Land ist '' (leerer String)</li>
                                            <li>Land ist 0</li>
                                            <li data-poll="correct">Es kommt ein Fehler</li>
                                        </ul>
                                    <h2>https://fraage.de</h2>
                                </div>
                                <aside class="notes">Später beim <code>INSERT</code>-Kommando wird gezeigt, dass man nicht zwangsweise alle Spaltenwerte beim Einfügen einer neuen Zeile setzen muss. Die DEFAULT-Option legt für solche Fälle den Standardwert fest. Gibt es keinen definierten DEFAULT-Wert und wird der Wert nicht gesetzt, erhält die Zeile in der entsprechenden Spalte den Wert NULL. Ist auf der Spalte ein <code>NOT NULL</code>-Constraint definiert, kommt ein Fehler. Vor solchen Fehlern kann dann ein DEFAULT-Wert schützen. Wird mittels <code>ALTER TABLE ... ADD COLUMN</code> nachträglich eine neue Spalte mit DEFAULT-Wert einer existierenden Tabelle hinzugefügt, erhalten alle bisherigen Zeilen in der neuen Spalte diesen DEFAULT-Wert.</aside>
                            </section>

                            <section>
                                    <h3>Sequenzen / Autoincrement</h3>
                                    <p class="small">Primärschlüsselwerte (z. B. IDs) automatisch erzeugen lassen.</p>
                                    <h4>In MySQL:</h4>
                                    <pre style="width: 95%;"><code class="sql" data-trim contenteditable>CREATE TABLE kunden(kundennr INT PRIMARY KEY AUTO_INCREMENT, ...);</code></pre>
                                    <h4>In PostgreSQL (aber auch MySQL):</h4>
                                    <pre style="width: 95%;"><code class="sql" data-trim contenteditable>CREATE TABLE kunden(kundennr SERIAL PRIMARY KEY  , ...);</code></pre>
                                    <aside class="notes">In verschiedenen DBMS gibt es die Spaltenoption <code>AUTO_INCREMENT</code> (MySQL), <code>AUTOINCREMENT</code> (SQLite), <code>GENERATED BY DEFAULT AS IDENTITY</code> (SQL Standard, Oracle, DB2), <code>IDENTITY</code> (Microsoft SQL Server), o. ä. Spalten mit dieser Option müssen einen nummerischen Datentypen haben. Eingefügte Zeilen erhalten standardmäßig eine automatisch generierte laufende Nummer. Problematisch kann es werden, wenn nan beim Einfügen auch selbst einen Wert setzt, statt ihn automatisch generieren zu lassen. Der SQL Standard und DB2 unterstützen <code>INTEGER GENERATED ALWAYS AS IDENTITY</code>, damit immer (nicht nur als Default) eine automatische ID erzeugt wird.</aside>
                                </section>

                            <section>
                                <h3>CHECK-Constraint</h3>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 47</div>
                                <pre><code class="sql" data-trim contenteditable>CREATE TABLE kunden (/* ... */,
 email VARCHAR(500) CHECK (email LIKE '%@%'));</code></pre>
                     <pre><code class="sql" data-trim contenteditable>CREATE TABLE bewertungen (/* ... */,
 sterne INT CHECK (sterne BETWEEN 1 AND 5));</code></pre>
                     <pre><code class="sql" data-trim contenteditable>CREATE TABLE personen (/* ... */,
 geburtsdatum DATE,
 hochzeitsdatum DATE CHECK (hochzeitsdatum > geburtsdatum));</code></pre>

                                <div class="poll fragment" style="bottom:-290px">
                                    <h1>Was ist kein Constraint?</h1>
                                        <ul>
                                            <li>CHECK</li>
                                            <li>PRIMARY KEY</li>
                                            <li>FOREIGN KEY</li>
                                            <li data-poll="correct">DEFAULT</li>
                                            <li>UNIQUE</li>
                                            <li>NOT NULL</li>
                                        </ul>
                                    <h2>https://fraage.de</h2>
                                </div>

                            <aside class="notes">Mit einem CHECK-Constraint lassen sich benutzerdefinierte Spalten-Constraints definieren. In Klammern hinter dem Stichwort <code>CHECK</code> steht ein beliebiger boolescher Ausdruck, der stets wahr sein muss. Beim Einfügen und Ändern von Zeilen überprüft das DBMS die Bedingung und lehnt die entsprechende Operation ab, wenn das CHECK-Constraint verletzt würde. In den gezeigten Beispielen muss in der E-Mail-Spalte immer ein @-Zeichen vorkommen, der Wertebereich der Sterne-Spalte wird eingeschränkt auf ganze Zahlen zwischen 1 und 5, und das Hochzeitsdatum muss immer echt später sein als das Geburtsdatum einer Person.</aside>
                            </section>
                            
                            <section>
                                    <h2>CREATE TABLE LIKE / AS</h2>
                                    <div class="trackinfo"><i class="fas fa-headphones"></i> 51</div>
                                    <h4>CREATE TABLE</h4>
                                    <pre><code class="sql" data-trim contenteditable>CREATE TABLE pkw (bez VARCHAR(50) PRIMARY KEY, leistung INT);</code></pre>

                                    <div class="fragment">
                                    <h4>CREATE TABLE LIKE</h4>
                                    <pre><code class="sql" data-trim contenteditable>CREATE TABLE lkw (LIKE pkw);</code></pre>
                                    </div>

                                    <div class="fragment">
                                    <h4>CREATE TABLE AS</h4>
                                    <pre><code class="sql" data-trim contenteditable>CREATE TABLE schrottkarren AS 
 SELECT * FROM pkw WHERE leistung < 60;</code></pre>
                                    </div>

                                    <aside class="notes">Alle drei hier gezeigten Befehle erstellen eine Tabelle. Bei der ersten gibt man die Spalten der Tabelle an, beim <code>CREATE TABLE LIKE</code> wird eine Tabelle mit den gleichen Spalten erstellt wie eine schon existierende Tabelle und <code>CREATE TABLE AS</code> speichert das Ergebnis einer SELECT-Anfrage in eine neu zu erstellende Tabelle. In den ersten beiden Kommandos ist die neue Tabelle leer, beim dritten Kommando können Daten in der neuen Tabelle sein. Mit <code>CREATE TABLE T2 AS SELECT * FROM T1</code> kann man eine Tabelle komplett mit Struktur und Daten kopieren.</aside>
                            </section>

                            

                            <section>
                                    <h2>ALTER / DROP</h2>
                                    <div class="trackinfo"><i class="fas fa-headphones"></i> 52</div>

                                    <p>ALTER: Verändern von Datenbankobjekten</p>
                                    <pre><code class="sql" data-trim contenteditable>ALTER TABLE bewertungen ADD COLUMN zeitstempel TIMESTAMP;</code></pre>
    
                                    <p class="fragment" data-fragment-index="1">DROP: Entfernen von Datenbankobjekten</p>
                                    <pre class="fragment" data-fragment-index="1"><code class="sql" data-trim contenteditable>DROP TABLE bewertungen;</code></pre>
                                    <aside class="notes">Die DDL-Befehle ALTER und DROP wirken sich genau wie CREATE auf den DB-Katalog aus. Das hier gezeigte ALTER TABLE ... ADD COLUMN-Kommando fügt eine neue Spalte namens &quot;zeitstempel&quot; vom Typ TIMESTAMP der Bewertungstabelle hinzu. Das gezeigte DROP-Kommando würde die Bewertungstabelle entfernen. Das heißt, es sind nicht nur alle Daten dieser Tabelle weg, sondern die ganze Tabelle existiert nicht mehr. Das DROP-Kommando hier würde aber abgelehnt werden, da es noch eine Tabelle Bewertungslikes gibt, bei der auf die Bewertungstabelle Fremdschlüsselreferenzen definiert sind. Man müsste also zunächst diese Tabelle oder zumindest die Fremdschlüssel droppen.</aside>
                            </section>

                            <section>
                                <h3>DML: INSERT, UPDATE, DELETE, ...</h3>
                                <p>Einfügen, ändern, löschen, abrufen von Daten.</p>
                                <pre style="width: 95%;"><code class="sql" data-trim contenteditable>INSERT INTO produkte(produktnr, bezeichnung, preis, hersteller) 
VALUES (88, 'Katzenfutter', 4.99, NULL)</code></pre>
                                <pre style="width: 95%;"><code class="sql" data-trim contenteditable>UPDATE produkte SET preis = 5.99 WHERE produktnr = 88</code></pre>
                                <pre style="width: 95%;"><code class="sql" data-trim contenteditable>DELETE FROM produkte WHERE produktnr = 88</code></pre>
                                <aside class="notes">Hier wird das Produkt Katzenfutter mit der Produktnummer 88 eingefügt, dann der Preis auf 5,99 EUR erhölt und im dritten Kommando wird die Zeile wieder gelöscht.</aside>
                            </section>

                            <section>
                                <h2>INSERT</h2>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 53</div>
                                <pre style="width: 95%;"><code class="sql" data-trim contenteditable>INSERT INTO produkte(produktnr, bezeichnung, preis, hersteller) 
VALUES (88, 'Katzenfutter', 4.99, NULL)</code></pre>
                                
                                <div class="fragment">
                                <p class="small">Nur ein Teil der Spalten setzen:</p>
                                <pre style="width: 95%;"><code class="sql" data-trim contenteditable>INSERT INTO produkte(preis, bezeichnung)
VALUES (4.99, 'Katzenfutter')</code></pre>
                                </div>

                                <div class="fragment    ">
                                <p class="small">Spaltennamen weglassen:</p>
                                <pre style="width: 95%;"><code class="sql" data-trim contenteditable>INSERT INTO produkte VALUES (88, 'Katzenfutter', 4.99, NULL)</code></pre>
                                </div>
                                <p class="fragment small">Nachteile: Schwerer verständlich zu lesen, man muss auf die korrekte Reihenfolge achten, man darf keine Spalte vergessen, in der Zukunft könnten sich die Spalten ändern.</p>
                                
                                <aside class="notes">Wenn nur ein Teil der Tabellenspalten gesetzt werden, werden die anderen Spalten auf ihre DEFAULT-Werte, den nächsten AUTO_INCREMENT / SERIAL-Wert oder auf NULL gesetzt. Lässt man die Spaltennamen vor dem Stichwort <code>VALUES</code> weg, müssen alle Spalten der Tabelle in der richtigen Reihenfolge gesetzt werden. Wenn in der Zukunft eine neue Spalte in die Produkttabelle hinzugefügt wird, würde das untere Kommando nicht mehr funktionieren.</aside>
                            </section>
                            
                            <section>
                                <h2>UPDATE</h2>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 54</div>
                                <pre><code class="sql" data-trim contenteditable>UPDATE produkte SET preis = 5.99 WHERE produktnr = 88</code></pre>

                                <pre class="fragment"><code class="sql" data-trim contenteditable>UPDATE produkte 
SET preis = 5.99, bezeichnung = 'Spezial-Katzenfutter' 
WHERE produktnr = 88</code></pre>

                                <div class="poll fragment fade-in-then-out" style="bottom:-220px">
                                    <h1>Was wird geändert, wenn man kein WHERE-Prädikat angibt?</h1>
                                        <ul>
                                            <li>Nur die erste Zeile</li>
                                            <li data-poll="correct">Alle Zeilen</li>
                                            <li>Gar nichts</li>
                                            <li>Es kommt ein Fehler</li>
                                        </ul>
                                    <h2>https://fraage.de</h2>
                                </div>

                                <pre class="fragment"><code class="sql" data-trim contenteditable>UPDATE produkte SET preis = preis+1</code></pre>

                                <pre class="fragment"><code class="sql" data-trim contenteditable>UPDATE produkte SET preis = preis * 1.1</code></pre>
                                <aside class="notes">Das UPDATE-Kommando besteht aus einem SET-Teil und einem WHERE-Teil. Im SET werden Komma-getrennte Zuweisungen angegeben, um die neuen Spaltenwerte zu setzen. Der WHERE-Teil besteht aus einer Bedingung, die für eine Zeile erfüllt sein muss, damit diese entsprechend geändert wird. Lässt man die WHERE-Klausel weg, steht dies für <code>WHERE TRUE</code>, man ändert also alle Zeilen.</aside>
                            </section>
                            <section>
                                <h2>DELETE / TRUNCATE TABLE</h2>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 55</div>
                                <pre><code class="sql" data-trim contenteditable>DELETE FROM produkte WHERE produktnr = 88</code></pre>

                                <pre><code class="sql" data-trim contenteditable>DELETE FROM produkte WHERE hersteller = 'Monsterfood'
                       AND preis < 1.00 
                                </code></pre>

                                <pre class="fragment"><code class="sql" data-trim contenteditable>DELETE FROM produkte</code></pre>

                                <pre class="fragment"><code class="sql" data-trim contenteditable>TRUNCATE TABLE produkte</code></pre>

                                <div class="poll fragment" style="bottom:-260px">
                                    <h1>Was ist der Unterschied zwischen TRUNCATE TABLE und DROP TABLE?</h1>
                                        <ul>
                                            <li>TRUNCATE ist schneller</li>
                                            <li>TRUNCATE löscht die Tabelle aus dem Metadaten-Katalog der Datenbank</li>
                                            <li data-poll="correct">TRUNCATE löscht nur die Daten, die Tabelle ist noch da</li>
                                            <li>Es gibt keinen</li>
                                        </ul>
                                    <h2>https://fraage.de</h2>
                                </div>

                                <aside class="notes">Auch hier bestimmt die WHERE-Klausel wieder, welche Zeilen gelöscht werden sollen. Lässt man sie weg, löscht das System jede Zeile. Der TRUNCATE TABLE-Befehl ist jedoch meist schneller für solche Zwecke, er leert ebenfalls die komplette Tabelle.</aside>
                            </section>
                            <section>
                                <h2>SELECT</h2>
                                <pre style="width: 95%;"><code class="sql" data-trim contenteditable>SELECT H.land, COUNT(*) AS anzahl, AVG(P.preis) AS avg_preis
FROM hersteller H JOIN produkte P ON H.firma = p.hersteller
WHERE P.preis > 3
GROUP BY h.land
HAVING COUNT(*) < 5
ORDER BY COUNT(*)
                                </code></pre>
                                
                                <p class="small">&quot;Zeige mir für jedes Land, in welchem weniger als fünf Produkte, die mehr als 3 EUR kosten, hergestellt wurden, die Anzahl der Produkte sowie die Durchschnittspreise an, aufsteigend sortiert nach der Anzahl.</p>
                            <ul class="small">
                                <li><code>SELECT</code>: Projektion</li>
                                <li><code>FROM</code>: Tabellen und Joins</li>
                                <li><code>WHERE</code>: Selektion</li>
                                <li><code>GROUP BY</code>: Zeilen gruppieren</li>
                                <li><code>HAVING</code>: Selektion nach der Gruppierung</li>
                                <li><code>ORDER BY</code>: Ergebnis sortieren</li>
                            </ul>
                            </section>
                            <section>
                                <h3>SELECT &lt;spalten&gt; FROM &lt;tabelle&gt;</h3>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 57</div>
                                <pre><code class="sql" data-trim contenteditable>SELECT bezeichnung, preis, round(preis * 1.15, 2) AS preis_usd 
FROM produkte</code></pre>
                                <span class="sqlresult fragment"></span>

                                <div class="poll fragment" style="bottom:-40px" data-hide-from="2V">
                                    <h1>Was macht dieses SELECT?</h1>
                                        <ul>
                                            <li>Selektion</li>
                                            <li data-poll="correct">Projektion ohne Duplikateliminierung</li>
                                            <li>Kreuzprodukt</li>
                                            <li>Weder noch</li>
                                        </ul>
                                    <h2>https://fraage.de</h2>
                                </div>
                                <aside class="notes">Die SELECT-Klausel wird bei der Anfrageausführung erst sehr spät ausgewertet. In ihr findet die Projektion statt, um festzulegen, welche Spalten man letztendlich im Ergebnis sehen möchte. Man kann mehrere Spalten mit Kommata trennen, mit <code>AS</code> einen Alias definieren - also eine Umbenennung vornehmen - und man kann Funktionen aufrufen. In der FROM-Klausel stehen eine oder mehrere Tabellen, aus der die Daten stammen sollen.</aside>
                            </section>
                            <section>
                                <h3>SELECT * FROM &lt;tabelle&gt;</h3>
                                <pre><code class="sql" data-trim contenteditable>SELECT * FROM produkte</code></pre>
                                <span class="sqlresult fragment"></span>
                                <aside class="notes">Mit <code>SELECT *</code> wird das ganze Tupel ausgegeben. In der Anfrage auf dieser Folio werden alle Spalten der Produkte-Tabelle angezeigt.</aside>
                            </section>
                            <section>
                                <h3>SELECT DISTINCT</h3>
                                <div class="columns">
                                    <div style="width: 8cm;">
                                            <pre><code class="sql" data-trim contenteditable data-sql="select_no_distinct">SELECT hersteller 
FROM produkte</code></pre>
                                            <span id="select_no_distinct"></span>
                                    </div>
                                    <div style="width: 12cm">
                                            <pre><code class="sql" data-trim contenteditable data-sql="select_distinct">SELECT DISTINCT hersteller 
FROM produkte</code></pre>
                                            <span id="select_distinct"></span>
                                    </div>
                                </div>
                                
                                <aside class="notes">In SQL wird standardmäßig keine Duplikateliminierung vorgenommen. Das Ergebnis einer Anfrage kann also - anders als in der relationalen Algebra - gleiche Zeilen doppelt beinhalten. Um eine Duplikateliminierung durchzuführen schreibt man <code>SELECT DISTINCT</code> statt <code>SELECT</code>.</aside>
                            </section>
                            <section>
                                <h2>WHERE</h2>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 58</div>
                                <div style="position: absolute; top: -1cm; right:5px; font-size:170px" class="green">&sigma;</div>
                                <pre><code class="sql" data-trim contenteditable data-sql="where_price_gt_3">SELECT * FROM produkte WHERE preis > 3</code></pre>
                                <span id="where_price_gt_3"></span>
                                <pre class="fragment"><code class="sql dont_execute_sql" data-trim contenteditable data-sql="where_price_gt_3">SELECT * FROM produkte WHERE preis >= 3 AND preis <= 9</code></pre>
                                <pre class="fragment"><code class="sql dont_execute_sql" data-trim contenteditable data-sql="where_price_gt_3">SELECT * FROM produkte WHERE preis BETWEEN 3 AND 9</code></pre>
                                <aside class="notes">In der WHERE-Klausel steht eine beliebige boolesche Bedingung. Alle Zeilen, die diese Bedingung erfüllen, sind im Ergebnis. Es wird also eine Selektion ausgeführt. Hat eine Anfrage keine WHERE-Klausel, qualifiziert sich jede Zeile. Bedingungen lassen sich mit AND und OR verknüpfen und mit NOT negieren. Auch die Klammerung von Ausdrücken ist möglich.</aside>
                            </section>
                            <section>
                                <h2>LIKE-Prädikat</h2>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 59</div>
                                <pre><code class="sql" data-trim contenteditable data-sql="where_description">SELECT * FROM produkte WHERE bezeichnung = 'Müsliriegel'</code></pre>
                                <span id="where_description"></span>
                                <pre><code class="sql" data-trim contenteditable data-sql="where_description_like">SELECT * FROM produkte WHERE bezeichnung LIKE 'M%'</code></pre>
                                <span id="where_description_like"></span>
                                <pre class="fragment"><code class="sql dont_execute_sql" data-trim contenteditable>SELECT * FROM produkte WHERE bezeichnung LIKE '%-%'</code></pre>
                                <pre class="fragment"><code class="sql dont_execute_sql" data-trim contenteditable>SELECT * FROM produkte WHERE bezeichnung LIKE 'M_sliriegel'</code></pre>
                                <div class="poll fragment" style="bottom:150px">
                                    <h1>Was würde durch die untere Anfrage gefunden werden?</h1>
                                        <ul>
                                            <li data-poll="correct">Masliriegel</li>
                                            <li>Muesliriegel</li>
                                            <li>Msliregel</li>
                                            <li>Keines davon</li>
                                        </ul>
                                    <h2>https://fraage.de</h2>
                                </div>
                                <aside class="notes">Strings müssen stets in 'einfache Anführungszeichen' geschrieben werden. 'Innerhalb eines Strings braucht''s zwei Anführungszeichen', um es zu escapen. Im LIKE-Prädikat wird eine Musterüberprüfung vorgenommen. <code>%</code> steht dabei für beliebige Zeichen und <code>_</code> für genau ein beliebiges Zeichen.</aside>
                            </section>
                            <section>
                                <h2>NULL-Werte</h2>
                                <pre><code class="sql" data-trim contenteditable data-sql="where_is_null">SELECT * FROM produkte WHERE hersteller IS NULL</code></pre>
                                <span id="where_is_null"></span>
                                <pre><code class="sql dont_execute_sql" data-trim contenteditable>SELECT * FROM produkte WHERE hersteller IS NOT NULL</code></pre>
                                <div class="poll fragment" style="bottom:-100px">
                                    <h1>hersteller = NULL ist...</h1>
                                        <ul>
                                            <li>immer true</li>
                                            <li data-poll="correct">immer false</li>
                                            <li>true, wenn hersteller NULL ist</li>
                                            <li>false, wenn hersteller NULL ist</li>
                                        </ul>
                                    <h2>https://fraage.de</h2>
                                </div>
                                <aside class="notes">Überprüfungen, ob der Wert einer Spalte NULL ist, muss mit <code>IS NULL</code> erfolgen. Das Prädikat <code>IS NOT NULL</code> trifft auf Zeilen zu, die in der entsprechenden Spalte keinen NULL-Wert haben.</aside>
                            </section>
                            <section>
                                <h2>Kreuzprodukt</h2>
                                <div style="position: absolute; top: -1cm; right:5px; font-size:170px" class="green">&times;</div>
                                <pre><code class="sql" data-trim contenteditable>SELECT * FROM produkte, hersteller</code></pre>
                                                                       <span class="sqlresult"></span>
                                <aside class="notes">Listet man Komma-getrennt mehrere Tabellen in der FROM-Klausel auf, wird das kartesische Produkt (Cross-Join) zwischen diesen gebildet. Jede Zeile der einen Tabelle wird mit jeder Zeile der anderen verbunden.</aside>
                            </section>

                            <section data-hide-from="!2V">
                                <h2>Join (Verbund)</h2>
                                <div style="position: absolute; top: -1cm; right:5px; font-size:170px" class="green">&bowtie;</div>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 24</div>
                                <p>Ein Join ist ein Kreuzprodukt mit anschließender Selektion, welche die Spaltenwerte der beiden Relationen vergleicht</p>
                                <h4>Gleichverbund (Equi-Join)</h4>
<pre><code class="sql" data-trim contenteditable>SELECT * FROM produkte JOIN hersteller 
ON produkte.hersteller = hersteller.firma</code></pre>                                
                                <pre><code class="sql" data-trim contenteditable>SELECT * FROM produkte, hersteller
WHERE produkte.hersteller = hersteller.firma</code></pre>
                                <p class="fragment">Es gilt: <code>R JOIN S</code> = <code>S JOIN R</code></p>
                                <aside class="notes"><code>R JOIN S ON P</code> bedeutet, dass die beiden Relationen R und S anhand des Join-Prädikats P verbunden werden.</aside>
                            </section>

<section data-hide-from="2V">
                                    <h2>Join</h2>
                                    <div style="position: absolute; top: -1cm; right:5px; font-size:170px" class="green">&bowtie;</div>
                                    <pre><code class="sql" data-trim contenteditable>SELECT * FROM produkte, hersteller
WHERE produkte.hersteller = hersteller.firma
                                    </code></pre>
                                                                           <span class="sqlresult"></span>
                                    <aside class="notes">In der WHERE-Klausel lässt sich im Anschluss an das kartesische Produkt eine Join-Bedingung definieren, sodass sich ein Verbund wie hier auf der Folie gezeigt ausführen lässt.</aside>
                                </section>
                            <section>
                                <h3>&lt;tabelle&gt; JOIN &lt;tabelle&gt; ON &lt;präd.&gt;</h3>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 61-62</div>
                                <pre><code class="sql" data-trim contenteditable>SELECT * FROM produkte JOIN hersteller 
 ON produkte.hersteller = hersteller.firma</code></pre>
                                <span class="sqlresult"></span>

                                <div class="fragment">
                                <p class="small">   </p>
                                <h4>Tabellen-Alias</h4>
                                <pre><code class="sql dont_execute_sql" data-trim contenteditable>SELECT * FROM produkte P JOIN hersteller H
 ON P.hersteller = H.firma</code></pre>
                                </div>
                                <aside class="notes">Die <code>JOIN ... ON</code>-Syntax in der FROM-Klausel ist eine Alternative zum Join in der WHERE-Klausel. An ihr ist besser erkennbar, dass hier ein Join ausgeführt wird, es verhindert, dass man aus Versehen die Join-Bedingung vergisst und es trennt klar den Verbund von weiteren Prädikaten. Außerdem lässt sich mit der <code>JOIN</code>-Klausel auch einen äußeren Verbund auszuführen (siehe nächste Folie). Bei nicht eindeutigen Spaltennamen muss unbedingt ein Tabellenprefix vor die Spalte geschrieben werden. Um Anfragen kompakter zu gestalten, bietet es sich an Tabellenaliase in der FROM-Klausel einzuführen (hier: P und H).</aside>
                            </section>


                            <section data-hide-from="!2V">
                                <h3>Suche nach Join-Partnern</h3>
                                <pre><code class="sql" data-trim contenteditable>SELECT * FROM produkte JOIN hersteller 
ON produkte.hersteller = hersteller.firma</code></pre>          
                                <div class="columns">
                                    <div data-sql-query="select * from produkte where produktnr < 90" data-sql-tablename="produkte"></div>
                                    <div>&nbsp;&nbsp;&nbsp;</div>
                                    <div data-sql-query="select * from hersteller" data-sql-tablename="hersteller"></div>
                                </div>
                                <aside class="notes">Man kann sich die Ausführung eines Joins auch so vorstellen, dass eine Relation von oben nach unten durchscannt wird - z. B. hier die Produkttabelle - und für jede Zeile ein (oder kein oder mehrere) Join-Partner in der anderen Relation - hier: Hersteller - gesucht wird. Die Attributwerte der gefundenen Zeile wird an die Ergebniszeile drangehangen. Wird kein Join-Partner gefunden - hier beim Katzenfutter der Fall -, taucht die Zeile nicht im Ergebnis auf. Würde eine Zeile mehrere Joinpartner finden, taucht sie mehrfach im Ergebnis auf. Jeweils einmal mit dem entsprechenden Join-Partner.</aside>
                            </section>
                            <section data-hide-from="!2V">
                                <h3>Ergebnis des Joins</h3>
                                <pre><code class="sql" data-trim contenteditable>SELECT * FROM produkte JOIN hersteller 
ON produkte.hersteller = hersteller.firma</code></pre>          
                                <div data-sql-query="select * from produkte join hersteller on produkte.hersteller=hersteller.firma where produktnr < 90"></div>
                                <p>Der Join ist verlustbehaftet.</p>

                                <div class="poll fragment" style="bottom:-200px" data-fragment-index="1">
                                        <h1>Was ist verloren gegangen?</h1>
                                          <ul>
                                            <li>Produkte mit Hersteller NULL</li>
                                            <li>Hersteller, von denen es keine Produkte gibt</li>
                                            <li data-poll="correct">beides</li>
                                            <li>gar nichts</li>
                                          </ul>
                                        <h2>https://fraage.de</h2>
                                    </div>

                                <aside class="notes">Die Ergebnisrelation des Joins zwischen zwei Relationen besitzt alle Spalten beider Relationen. Zu jeder Zeile der beiden Relationen existieren entsprechend viele Zeilen im Ergebnis, je nachdem wie viele Join-Partner zu ihr gefunden werden. Der Hersteller Monsterfood hat sogar zwei Join-Partner gefunden, daher taucht die Hersteller-Zeile (Monsterfood, USA) im Ergebnis zweimal auf. Das Produkt Katzenfutter hat hier keinen Join-Partner gefunden, der Hersteller Holzkopf ebenfalls nicht. Da also beim Join etwas verloren gegangen ist (Katzenfutter und Hersteller Holzkopf), nennt man den Join verlustbehaftet.</aside>
                            </section>
                            <section data-hide-from="!2V">
                                <h3>Verlustfreier Join</h3>
                                
                                <div class="columns">
                                    <div data-sql-query="select * from produkte where produktnr in (17,18,29)" data-sql-tablename="produkte"></div>
                                    <div>&nbsp;&nbsp;&nbsp;</div>
                                    <div data-sql-query="select * from hersteller where firma in ('Calgonte', 'Monsterfood')" data-sql-tablename="hersteller"></div>
                                </div>
                                <pre><code class="sql" data-trim contenteditable>SELECT * FROM produkte JOIN hersteller 
ON produkte.hersteller = hersteller.firma</code></pre>          
                                <div data-sql-query="select * from produkte join hersteller on produkte.hersteller=hersteller.firma where produktnr in (17,18,29)"></div>
                                <aside class="notes">Hier taucht jedes Tupel aus beiden Relationen im Join-Ergebnis auf. Der Join ist verlustfrei.</aside>
                            </section>
                            <section data-hide-from="!2V">
                                <h3>Rekonstruktion der Tabellen</h3>
                                <div data-sql-tablename="V" data-sql-query="select * from produkte join hersteller on produkte.hersteller=hersteller.firma where produktnr in (17,18,29)"></div>
                            
                                <pre><code class="sql" contenteditable>-- Produkte
SELECT DISTINCT produktnr, bezeichnung, preis, hersteller FROM V</code></pre>
                                <pre><code class="sql" contenteditable>-- Hersteller
SELECT DISTINCT firma, land FROM V</code></pre>
                                <aside class="notes">Aus dem Join-Ergebnis V lassen sich die beiden ursprünglichen Relationen wieder mittels Projektionen rekonstruieren. Das funktioniert allerdings nur, wenn der Verbund verlustfrei ist.</aside>
                            </section>

                            <section data-hide-from="!2V">
                                <h2>Äußerer Verbund</h2>
                                <h4><code>INNER JOIN</code> - Innerer Verbund</h4>
                                <p>Nur die Zeilen, die Join-Partner finden, sind im Ergebnis</p>
                                <h4><code>LEFT [OUTER] JOIN</code> - Linker äußerer Verbund</h4>
                                <p>Alle Zeilen der linken Relation sind definitiv im Ergebnis</p>
                                <h4><code>RIGHT [OUTER] JOIN</code> - Rechter äußerer Verbund</h4>
                                <p>Alle Zeilen der rechten Relation sind definitiv im Ergebnis</p>
                                <h4><code>FULL [OUTER] JOIN</code> - Voller äußerer Verbund</h4>
                                <p>Alle Zeilen beider Relation sind definitiv im Ergebnis</p>
                            </section>

                            <section data-hide-from="!2V">
                                <h3><code>LEFT [OUTER] JOIN</code></h3>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 27</div>
                                <pre><code class="sql" data-trim contenteditable>SELECT * FROM produkte P LEFT JOIN hersteller H 
ON P.hersteller = H.firma</code></pre>      
                                <div data-sql-query="select * from produkte left join hersteller on produkte.hersteller=hersteller.firma where produktnr < 90"></div>
                                <aside class="notes">Alle Zeilen der links vom <code>LEFT JOIN</code>-Operator stehenden Relation erscheinen auf jeden Fall im Ergebnis. Wenn sie keinen Join-Partner in der rechten Tabelle finden - das ist hier beim Katzenfutter der Fall -, bleiben die Attribute der rechten Tabelle alle NULL.</aside>
                            </section>
                            <section data-hide-from="!2V">
                                <h3><code>RIGHT [OUTER] JOIN</code></h3>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 28</div>
                                <pre><code class="sql" data-trim contenteditable>SELECT * FROM produkte P RIGHT JOIN hersteller H 
ON P.hersteller = H.firma</code></pre> 
                                <div data-sql-query="select produkte.*, hersteller.* from hersteller left join (select * from produkte where produktnr < 90) produkte on produkte.hersteller=hersteller.firma"></div>
                                <p>Es gilt: <code>R RIGHT JOIN S</code> = <code>S LEFT JOIN R</code></p>
                                <aside class="notes">Beim <code>RIGHT OUTER JOIN</code> sind zusätzlich zu den normalen Join-Ergebniszeilen diejenigen Zeilen der rechten Tabelle im Ergebnis wiederzufinden, die keinen Join-Partner in der linken Tabelle finden. Auch hier werden die Spalten der linken Tabelle mit NULL-Werten belegt.</aside>
                            </section>
                            <section data-hide-from="!2V">
                                <h3><code>FULL [OUTER] JOIN</code></h3>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 29</div>
                                <pre><code class="sql" data-trim contenteditable>SELECT * FROM produkte P FULL JOIN hersteller H 
ON P.hersteller = H.firma</code></pre> 
                                <div data-sql-query="select * from produkte left join hersteller on produkte.hersteller=hersteller.firma where produktnr < 90
                                union all select null,null,null,null, hersteller.* from hersteller where firma = 'Holzkopf'"></div>
                                <p>Es gilt: <code>R FULL JOIN S</code> = <code>S FULL JOIN R</code></p>
                                <aside class="notes">Jede Zeile der linken Relation und jede Zeile der rechten Relation tauchen stets im Ergebnis des full outer Joins auf. Der volle äußere Verbund ist damit immer verlustfrei.</aside>
                            </section>

                            
                            <section data-hide-from="2V">
                                <h3>LEFT/RIGHT/FULL [OUTER] JOIN</h3>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 63</div>
                                <pre><code class="sql" data-trim contenteditable>SELECT * FROM produkte P LEFT JOIN hersteller H
 ON P.hersteller = H.firma</code></pre>
                                <span class="sqlresult"></span>
                                <aside class="notes">Ein äußerer Verbund lässt sich ausführen, indem statt dem <code>JOIN</code>-Schlüsselwort <code>LEFT JOIN</code>, <code>RIGHT JOIN</code> oder <code>FULL JOIN</code> geschrieben wird. Bei hier gezeigten linken äußeren Verbund sind alle Zeilen der linken Tabelle im Join-Ergebnis. Diejenigen, die keinen Join-Partner in der rechten Tabelle finden, erhalten in den entsprechenden Spalten einen NULL-Wert.</aside>
                            </section>
                            <section data-hide-from="2V">
                                <h3>JOIN ... USING(...)</h3>
                                <pre><code class="sql" data-trim contenteditable>SELECT P.*, B.sterne 
 FROM produkte P JOIN bewertungen B USING(produktnr)</code></pre>
                                <span class="sqlresult"></span>
                                <div class="poll fragment" style="bottom:-300px">
                                    <h1>Welche Aussage ist falsch?</h1>
                                        <ul>
                                            <li data-poll="correct">Die Anfrage entspricht einem äußeren Verbund</li>
                                            <li>Die Anfrage entspricht einem natürlichen Verbund</li>
                                            <li>Die Anfrage entspricht ON P.produktnr = B.produktnr</li>
                                            <li>Die Anfrage funktioniert nur, wenn beide Tabellen die Spalte produktnr haben</li>
                                        </ul>
                                    <h2>https://fraage.de</h2>
                                </div>
                                <aside class="notes"><code>USING(produktnr)</code> ist eine verkürzte Schreibweise für den Equi-Join auf der Spalte Produktnummer, also in dem Fall für <code>ON P.produktnr = B.produktnr</code></aside>
                            </section>
                            <section>
                                <h2>Aggregatfunktionen</h2>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 64</div>
                                <ul>
                                    <li>COUNT: Anzahl</li>
                                    <li>SUM: Summe</li>
                                    <li>AVG: Durchschnittswert</li>
                                    <li>MIN: Kleinster Wert</li>
                                    <li>MAX: Größter Wert</li>
                                    <li>...</li>
                                </ul>
                                <p class="small">Aggregatfunktion in der SELECT-Liste ohne GROUP BY-Klausel<br>&Rightarrow; die ganze Tabelle bildet eine große Gruppe<br> &Rightarrow; es kommt nur eine Zeile raus.</p>
                            </section>
                            <section>
                                <h2>COUNT</h2>
                                <div class="columns">
                                <div style="width:6.8cm">
                                    <pre><code class="sql" data-trim contenteditable data-sql="count_star">SELECT COUNT(*) 
FROM produkte</code></pre>
                                    <span id="count_star"></span>
                                </div>
                                <div style="width:10.4cm">
                                    <pre><code class="sql" data-trim contenteditable data-sql="count_manufacturer">SELECT COUNT(hersteller) 
FROM produkte</code></pre>
                                    <span id="count_manufacturer"></span>
                                </div>
                                </div>
                                <pre><code class="sql" data-trim contenteditable data-sql="count_distinct_manufacturer">SELECT COUNT(DISTINCT hersteller) FROM produkte</code></pre>
                                <span id="count_distinct_manufacturer"></span>
                                <aside class="notes"><code>COUNT(*)</code> (manche schreiben auch gerne <code>COUNT(1)</code>) zählt die Anzahl der Zeilen in der Gruppe. Da hier die Gruppe die ganze Tabelle ist, liefert dies die Anzahl der Zeilen in der Tabelle. COUNT mit Spaltenangaben zählt, wie viele Zeilen in den gegebenen Spalten keinen NULL-Wert haben. <code>COUNT(DISTINCT ...)</code> zählt die von NULL verschiedenen distinkten (unterschiedlichen) Werte in den gegebenen Spalten. In unserem Beispiel existieren die beiden Werte Calgonte und Monsterfood in der Hersteller-Spalte.</aside>
                            </section>
                            <section>
                                <h2>SUM / AVG / MIN / MAX</h2>
                                <pre><code class="sql" data-trim contenteditable>SELECT SUM(preis), AVG(preis), MIN(preis), MAX(preis)
FROM produkte</code></pre>
                                <span class="sqlresult"></span>
                                <aside class="notes">Den Aggregatfunktionen SUM, AVG, MIN und MAX wird als Argument eine Spalte (oder ein Ausdruck, z. B. <code>SUM(preis * (1+steuersatz/100))</code> übergeben. Wir sehen hier im Ergebnis die Summe aller Preise, den Durchschnitt sowie den kleinsten und größten Preis. NULL-Werte werden in den Aggregatfunktionen übersprungen. Das heißt <code>AVG(preis)</code> berechnet sich aus der Summe der Preise, die nicht NULL sind, geteilt durch die Anzahl der Preise, die nicht NULL sind. Also: <code>SUM(preis)/COUNT(preis)</code></aside>
                            </section>
                            <section>
                                <h2>GROUP BY</h2>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 65</div>
                                <pre><code class="sql" data-trim contenteditable>SELECT hersteller, COUNT(*), AVG(preis)
FROM produkte
GROUP BY hersteller</code></pre>
<div class="poll fragment" style="bottom:-250px">
    <h1>Wie viele Zeilen kommen hier heraus?</h1>
        <ul>
            <li>0</li>
            <li>1</li>
            <li data-poll="correct">So viele, wie es verschiedene Werte in der hersteller-Spalte gibt</li>
            <li>So viele, wie es Zeilen in der Produkte-Tabelle gibt</li>
        </ul>
    <h2>https://fraage.de</h2>
</div>
                                <span class="sqlresult fragment"></span>
                                <aside class="notes">In der GROUP BY-Klausel werden Spalten spezifiziert, nach deren Werten Gruppen gebildet werden. <code>GROUP BY hersteller</code> bedeutet, dass für jeden distinkten Wert in der hersteller-Spalte eine Gruppe gebildet wird. In unserem Beispiel sind dies drei. Für jede Gruppe kann nun der Wert in dieser GROUP BY-Spalte ausgegeben werden. Alle anderen Spalten dürfen nur innerhalb von Aggregatfunktionen in der SELECT-Liste vorkommen. Wir berechnen in dem Beispiel auf dieser Folie für jeden einzelnen Hersteller die Anzahl und Durchschnittspreise seiner Produkte.</aside>
                            </section>
                            <section>
                                <h2>GROUP BY</h2>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 66</div>
                                <pre><code class="sql" data-trim contenteditable>SELECT hersteller, preis, COUNT(*)
FROM produkte
GROUP BY hersteller, preis</code></pre>
                                <span class="sqlresult"></span>
                                <aside class="notes">Hier gruppieren wir nach Hersteller und Preis. Das heißt für jede Kombination aus einem Hersteller und einem Preis wird eine Gruppe gebildet. Das Ergebnis lesen wir jetzt so: Vom Hersteller Calgonte gibt es ein Produkt, welches 3.99 kostet. Auch hier ist wieder darauf zu achten, dass im SELECT-Teil nur Spalten stehen dürfen, die im GROUP BY vorkommen. Alle anderen dürfen nur innerhalb von Aggregatfunktionen auftreten.</aside>
                            </section>
                            
                            <section>
                                <h2>HAVING</h2>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 69</div>
                                <pre><code class="sql" data-trim contenteditable>SELECT hersteller, AVG(preis)
FROM produkte
GROUP BY hersteller
HAVING COUNT(*) >= 2</code></pre>
                                <span class="sqlresult"></span>
                                <aside class="notes">Die Ausführungsreihenfolge von SELECT-Abfragen ist wie folgt: Zunächst werden die Daten aus den Tabellen geholt, die in der FROM-Klausel stehen, dann wird die WHERE-Klausel ausgewertet, um die Zeilen zu filtern. Im Anschluss daran erfolgt die Gruppierung und die Ausgabe der Spalten und berechneten Aggregatfunktionen in der SELECT-Liste. Möchte man nach der Gruppierung nochmals eine Selektion ausführen, verwendet man die HAVING-Klausel. In ihr stehen in der Regel nur Aggregatfunktionen, da man andere Prädikate ja bereits im WHERE-Teil ausführen kann. Im gezeigten Beispiel berechnen wir für jeden Hersteller, von dem es mindestens zwei Produkte gibt, die Durchschnittspreise dieser Produkte.</aside>
                            </section>

                            <section>
                                <h2>Sub-Anfragen</h2>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 67-68</div>
                                <pre><code class="sql dont_execute_sql" data-trim contenteditable>SELECT hersteller, avg_preis FROM (
 SELECT hersteller, COUNT(*) AS anzahl, AVG(preis) AS avg_preis 
 FROM produkte GROUP BY hersteller
) P WHERE anzahl >= 2</code></pre>
                                <pre class="fragment"><code class="sql dont_execute_sql" data-trim contenteditable>SELECT * FROM produkte
WHERE preis = (SELECT MAX(preis) FROM produkte)</code></pre>

<pre class="fragment"><code class="sql dont_execute_sql" data-trim contenteditable>SELECT * FROM produkte P1
WHERE preis = (SELECT MAX(preis) FROM produkte P2 
               WHERE P2.hersteller = P1.hersteller)</code></pre>
               <aside class="notes">Unteranfragen dürfen fast überall innerhalb einer Anfrage stehen, auch in INSERT, UPDATE, DELETE, usw. Auch korrelierende Sub-Anfragen sind erlaubt. In einer solchen kommen Spalten der Oberanfrage vor (P1.hersteller in der unteren Anfrage). Die obere Query entspricht der Anfrage mit HAVING aus der vorherigen Folie. Die zweite Anfrage liefert Produkte, die den Maximalpreis haben, es gibt also keine teureren als diese. Die untere Anfrage ist ähnlich: Sie liefert Produkte, die den Maximalpreis von Produkten vom jeweiligen Hersteller haben. Die Anfrage liefert z. B. den Müsliriegel, da es von seinem Hersteller Monsterfood keine Produkte gibt, die mehr kosten.</aside>
                            </section>

                            <section>
                                    <h3>CTE: Common Table Expressions</h3>
                                    <div class="trackinfo"><i class="fas fa-headphones"></i> 90</div>
                                    <h4><code>WITH ... AS (SELECT ...) SELECT ...</code></h4>
                                    <pre><code class="sql" data-trim contenteditable data-sql="cte_monsterfood">
WITH monsterfood_produkte AS 
 (SELECT * FROM produkte WHERE hersteller = 'Monsterfood')
SELECT count(*) FROM monsterfood_produkte</code></pre>
                                    <span id="cte_monsterfood"></span>
                                    <pre><code class="sql" data-trim contenteditable data-sql="cte_monsterfood2">
WITH monsterfood_produkte AS 
    (SELECT * FROM produkte WHERE hersteller = 'Monsterfood')
SELECT * FROM monsterfood_produkte
WHERE preis = (SELECT max(preis) FROM monsterfood_produkte)</code></pre>
                                    <span id="cte_monsterfood2"></span>

                                    <aside class="notes">Mit CTEs lassen sich Subanfragen Alias-Namen geben. Das ist vor allem dann praktisch, wenn man eine Unteranfrage mehrfach benötigt. Im unteren Beispiel suchen wir Monsterfood-Produkte, die den Höchstpreis aller Monsterfood-Produkte haben.</aside>
                                </section>

                            <section>
                                <h2>ORDER BY</h2>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 70</div>
                                <div style="position: absolute; top: 20px; right:5px; font-size:170px"><i class="fas fa-sort-amount-down-alt green"></i></div>
                                <p class="small">&quot;Tabellen haben keine Ordnung, Ergebnisse schon.&quot;</p>
                                <ul>
                                    <li><code>ASC</code>: aufsteigend sortieren (Standard)</li>
                                    <li><code>DESC</code>: absteigend sortieren</li>
                                </ul>
                                <pre><code class="sql" data-trim contenteditable>SELECT * FROM produkte ORDER BY preis</code></pre>
                                <span class="sqlresult"></span>
                                <div class="poll fragment" style="bottom:120px">
                                    <h1>Wenn zwei Produkte den gleichen Preis haben, welches kommt dann zuerst?</h1>
                                        <ul>
                                            <li>Das mit der kleinsten produktnr</li>
                                            <li>Das, was zuerst eingefügt wurde</li>
                                            <li>Das, was zuletzt eingefügt wurde</li>
                                            <li data-poll="correct">Keine Ahnung</li>
                                        </ul>
                                    <h2>https://fraage.de</h2>
                                </div>
                                <aside class="notes">Hier wird das Ergebnis der Anfrage aufsteigend nach den Werten der Preis-Spalte sortiert.</aside>
                            </section>

                            <section>
                                <h2>ORDER BY</h2>
                                <p class="small">&quot;Tabellen haben keine Ordnung, Ergebnisse schon.&quot;</p>
                                
                                <pre><code class="sql dont_execute_sql" data-trim contenteditable>SELECT * FROM produkte 
ORDER BY hersteller NULLS LAST, preis DESC</code></pre>
                                <span data-sql-query="SELECT * FROM produkte ORDER BY hersteller IS NULL, hersteller, preis DESC"></span>
                                <aside class="notes">Gibt man mehrere Ausdrücke im ORDER BY an, wird zuerst nach dem ersten sortiert, dann nach dem zweiten, usw. NULLS FIRST bzw. NULLS LAST sorgt dafür, dass NULL-Werte in der zu sortierenden Spalte an den Anfang bzw. ans Ende sortiert werden. Hier kommt Calgonte im Alphabet vor Monsterfood, aber da es zwei Produkte von Monsterfood gibt, kommt wegen <code>preis DESC</code> das teuerste zuerst.</aside>
                            </section>

                            <section>
                                <h2>LIMIT</h2>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 71</div>
                                <h4>SQL Standard (und DB2):</h4>
                                <pre><code class="sql dont_execute_sql" data-trim contenteditable>SELECT * FROM produkte ORDER BY preis DESC
FETCH FIRST 5 ROWS ONLY</code></pre>
                                <h4>PostgreSQL, MySQL, MariaDB, SQLite, ...</h4>
                                <pre><code class="sql dont_execute_sql" data-trim contenteditable>SELECT * FROM produkte ORDER BY preis DESC
LIMIT 5</code></pre>
                                <aside class="notes">Mit der LIMIT-Klausel lässt sich die Ergebnismenge auf eine bestimmte Anzahl von Tupeln begrenzen. <code>SELECT * FROM produkte LIMIT 5</code> würde irgendwelche fünf Produkte liefern. Die untere Anfrage auf dieser Folie liefert die fünf teuersten Produkte. <code>SELECT * FROM produkte ORDER BY preis DESC LIMIT 1</code> liefert das teuerste Produkt. Haben zwei Produkte den gleichen und den teuersten Preis, wird irgendeines von diesen ausgegeben.</aside>
                            </section>

                            <section>
                                <h2>LIMIT mit OFFSET</h2>
                                <pre><code class="sql dont_execute_sql" data-trim contenteditable>SELECT * FROM produkte ORDER BY preis DESC
LIMIT 2, 5</code></pre>
                                <pre><code class="sql" data-trim contenteditable>SELECT * FROM produkte ORDER BY preis DESC
LIMIT 5 OFFSET 2</code></pre>
                                <span class="sqlresult"></span>
                                <aside class="notes">Die beiden hier dargestellten Anfragen sind äquivalent. Der Offset sorgt dafür, dass zunächst eine bestimmte Anzahl von Zeilen übersprungen wird. Hier werden die beiden teuersten Produkte (Regal und Maschinenbau-Lehrbuch) übersprungen und erst die fünf danach teuersten Produkte ausgegeben.</aside>
                            </section>
                            <section>
                                    <h2>SELECT</h2>
                                    <pre style="width: 95%;"><code class="sql" data-trim contenteditable>SELECT H.land, COUNT(*) AS anzahl, AVG(P.preis) AS avg_preis
FROM hersteller H JOIN produkte P ON H.firma = p.hersteller
WHERE P.preis > 3
GROUP BY h.land
HAVING COUNT(*) < 5
ORDER BY COUNT(*)
                                    </code></pre>
                                    <p class="small">&quot;Zeige mir für jedes Land, in welchem weniger als fünf Produkte, die mehr als 3 EUR kosten, hergestellt wurden, die Anzahl der Produkte sowie die Durchschnittspreise an, aufsteigend sortiert nach der Anzahl.</p>
                                    <span class="sqlresult"></span>   
                                    <p class="small">Ich will im Ergebnis auch sehen, dass es z. B. aus Österreich 0 solche Produkte gibt!</p> 
                                </section>
                            
                                <section>
                                        <h2>SELECT mit OUTER JOIN</h2>
                                        <div class="trackinfo"><i class="fas fa-headphones"></i> 73</div>
                                        <pre><code class="sql" data-trim contenteditable>SELECT H.land, COUNT(*) AS anzahl, AVG(P.preis) AS avg_preis
FROM hersteller H LEFT JOIN produkte P ON p.hersteller = H.firma
WHERE P.preis > 3
GROUP BY h.land HAVING COUNT(*) < 5 ORDER BY COUNT(*)
                                        </code></pre>
                                        <p class="small">Problem: WHERE-Prädikat <code>preis > 3</code> wird nach dem äußeren Verbund ausgeführt, schmeißt also die gewünschten Zeilen mit NULL-Werten wieder raus.</p>
                                        <pre class="fragment"><code class="sql" data-trim contenteditable>SELECT /****/ 
WHERE P.preis > 3 OR P.produktnr IS NULL</code></pre>
<pre class="fragment"><code class="sql" data-trim contenteditable>SELECT H.land, COUNT(*) AS anzahl, AVG(P.preis) AS avg_preis
FROM hersteller H
 LEFT JOIN (SELECT * FROM produkte WHERE preis > 3) P 
 ON p.hersteller = H.firma
GROUP BY h.land HAVING COUNT(*) < 5 ORDER BY COUNT(*)</code></pre>

                                <aside class="notes">Ein LEFT JOIN alleine löst das Problem nicht, dass Länder ohne teure Produkte im Ergebnis nicht auftauchen. Hier sind zwei Lösungen. Die erste liefert die Zeilen, die beim Left Join keinen Joinpartner gefunden haben, die zweite erzwingt ein frühzeitiges Filtern vor der Ausführung des Joins.</aside>
                                    </section>

                        <section>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 74-75</div>
                                <div style="position: absolute; top: -0.5cm; right:5px; font-size:170px" class="green">&Union;</div>
                                <h2>UNION</h2>
                                <p class="small">Aus welchen Ländern sind unsere Kunden und Hersteller?</p>
                                <pre><code class="sql" data-trim contenteditable>
SELECT land FROM kunden
UNION
SELECT land FROM hersteller
                                </code></pre>
                                <span class="sqlresult"></span>
                                <div class="poll fragment" style="bottom:-20px">
                                    <h1>Was muss für die Spalten (hier: land) der beiden Teilanfragen gelten?</h1>
                                        <ul>
                                            <li>Sie müssen gleich heißen</li>
                                            <li data-poll="correct">Es müssen gleich viele sein</li>
                                            <li>Beides</li>
                                            <li>Weder noch</li>
                                        </ul>
                                    <h2>https://fraage.de</h2>
                                </div>
                                <p class="small">Bei Mengenoperationen ohne das Stichwort <code>ALL</code> wird nach UNION, INTERSECT und EXCEPT eine Duplikateliminierung vorgenommen.</p>
                        
                                <aside class="notes">Die Ergebnismengen zweier SELECT-Anfragen lassen sich mit Mengenoperatoren (UNION, UNION ALL, INTERSECT, INTERSECT ALL, EXCEPT, EXCEPT ALL) kombinieren.</aside>
                        </section>

                        <section>
                                <h2>UNION ALL</h2>
                                <p class="small">Aus welchen Ländern sind unsere Kunden und Hersteller?</p>
                                <pre><code class="sql" data-trim contenteditable>
SELECT land FROM kunden
UNION ALL
SELECT land FROM hersteller
                                </code></pre>
                                <span class="sqlresult"></span>
                                <aside class="notes">Auf der vorherigen Folie haben wir gesehen, dass jedes Land im Ergebnis nur einmal vorkommt. Das liegt daran, dass im Anschluss an Mengenoperationen ohne das Stichtwort <code>ALL</code> eine Duplikateliminierung vorgenommen wird. Hier sehen wir wegen <code>UNION ALL</code> auch doppelte Zeilen.</aside>
                        </section>

                        <section>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 76</div>
                                <h2>INTERSECT</h2>
                                <div style="position: absolute; top: -0.5cm; right:5px; font-size:170px" class="green">&Intersection;</div>
                                <p class="small">In welchen Ländern gibt es Kunden und Hersteller?</p>
                                <pre><code class="sql" data-trim contenteditable>
SELECT land FROM kunden
INTERSECT
SELECT land FROM hersteller
                                </code></pre>
                                <span class="sqlresult"></span>
                                <pre class="fragment"><code class="sql dont_execute_sql" data-trim contenteditable>
SELECT land FROM kunden
INTERSECT ALL
SELECT land FROM hersteller</code></pre>
                                <aside class="notes">INTERSECT bildet die Schnittmenge zwischen zwei Mengen. Wichtig bei allen Mengenoperationen ist, dass die Mengen vereinigungsverträglich sind. Die Anzahl der Spalten muss also gleich und die Datentypen der Spalten müssen zueinander kompatibel sein. INTERSECT ALL eliminiert keine Duplikate. Würde es also zwei Kunden aus Italien und drei Hersteller aus Italien geben, stände Italien zweimal im Ergebnis.</aside>
                                
                        </section>
                        
                        <section>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 76</div>
                                <h2>EXCEPT (MINUS)</h2>
                                <div style="position: absolute; top: -0.5cm; right:5px; font-size:170px" class="green">\</div>
                                <p class="small">In welchen Ländern gibt es Kunden, aber keine Hersteller?</p>
                                <pre><code class="sql" data-trim contenteditable>
SELECT land FROM kunden
EXCEPT
SELECT land FROM hersteller
                                </code></pre>
                                <span class="sqlresult"></span>

                                <pre><code class="sql dont_execute_sql" data-trim contenteditable>
                                        SELECT land FROM kunden
                                        EXCEPT ALL
                                        SELECT land FROM hersteller
                                </code></pre>
                                <span data-sql-query="SELECT 'Deutschland' AS land UNION ALL SELECT 'Deutschland' AS land   "></span>
                                <aside class="notes">Gibt es drei Kunden und ein Hersteller aus Deutschland, bleibt bei EXCEPT ALL 2x Deutschland übrig.</aside>
                        </section>

                        <section>
                            <h2>Das EXISTS-Prädikat</h2>
                            <div class="trackinfo"><i class="fas fa-headphones"></i> 78</div>
                            <div style="position: absolute; top: -0.5cm; right:5px; font-size:170px" class="green">&Exists;</div>
                            <ul>
                                <li>Eingabe: Eine SELECT-Anfrage</li>
                                <li>Ausgabe: <ul>
                                    <li>TRUE, wenn die Anfrage mind. 1 Zeile liefert</li>
                                    <li>FALSE, wenn die Anfrage die leere Menge liefert</li>
                                </ul></li>
                            </ul>
                            <pre><code class="sql" data-trim contenteditable>
SELECT * FROM hersteller H
WHERE EXISTS 
 (SELECT * FROM produkte P WHERE p.hersteller = H.firma)
                            </code></pre>
                            <span class="sqlresult"></span>
                            <div class="poll fragment" style="bottom:-50px">
                                <h1>Was liefert diese Anfrage?</h1>
                                    <ul>
                                        <li data-poll="correct">Hersteller, von denen es Produkte gibt</li>
                                        <li>Produkte, die einen Hersteller haben</li>
                                        <li>Hersteller, von denen es keine Produkte gibt</li>
                                        <li>Produkte mit Hersteller NULL</li>
                                    </ul>
                                <h2>https://fraage.de</h2>
                            </div>
                            <aside class="notes">Die Anfrage hier liefert Hersteller, von denen es Produkte gibt. Dies könnte man auch einfach mit einem (Semi-)Join lösen.</aside>
                        </section>

                        <section>
                                <h2>NOT EXISTS</h2>
                                <div style="position: absolute; top: -0.5cm; right:5px; font-size:170px" class="green">&NotExists;</div>
                                <p class="small">Von welchen Herstellern gibt es keine Produkte?</p>
                                <pre><code class="sql" data-trim contenteditable>
    SELECT * FROM hersteller H
    WHERE NOT EXISTS 
     (SELECT * FROM produkte P WHERE p.hersteller = H.firma)
                                </code></pre>
                                <span class="sqlresult"></span>
                                <aside class="notes">Für Hersteller, von denen es Produkte gibt, liefert die innere SELECT-Anfrage ein nicht-leeres Ergebnis (nämlich die Produkte des jeweiligen Herstellers). Für die anderen Hersteller (hier: Holzkopf) liefert die Unteranfrage ein leeres Ergebnis, EXISTS ist also FALSE, NOT EXISTS ist damit TRUE und der Hersteller wird ausgegeben.</aside>
                            </section>

                            <section>
                                    <h2>Das IN-Prädikat</h2>
                                    <div class="trackinfo"><i class="fas fa-headphones"></i> 79</div>
                                    <div style="position: absolute; top: -0.5cm; right:5px; font-size:170px" class="green">&Element;</div>
                                    <ul>
                                        <li>Eingabe: Ein Ausdruck und entweder eine Werte-Liste oder eine SELECT-Anfrage</li>
                                        <li>Ausgabe: <ul>
                                            <li>TRUE, wenn der Ausdruck enthalten ist</li>
                                            <li>FALSE, wenn der Ausdruck nicht enthalten ist</li>
                                        </ul></li>
                                    </ul>
                                    <pre><code class="sql" data-trim contenteditable>
SELECT * FROM hersteller H
WHERE firma IN ('Holzkopf', 'Monsterfood')
                                    </code></pre>
                                    <span class="sqlresult"></span>
                                    <aside class="notes">Hier erspart man durch die IN-Liste Schreibarbeit, da man ansonsten <code>WHERE hersteller = 'Holzkopf' OR hersteller = 'Monsterfood'</code> schreiben müsste.</aside>
                                </section>

                                <section>
                                    <h2>Das IN-Prädikat</h2>
                                    <div style="position: absolute; top: 5cm; right:5px; font-size:170px" class="green">&NotElement;</div>
                                    <pre><code class="sql" data-trim contenteditable data-sql="sql_in">
SELECT * FROM hersteller H
WHERE firma IN (SELECT hersteller FROM produkte)
                                    </code></pre>
                                    <span id="sql_in"></span>

                                    <pre><code class="sql" data-trim contenteditable data-sql="sql_not_in">
SELECT * FROM hersteller H
WHERE firma NOT IN 
 (SELECT hersteller FROM produkte WHERE hersteller IS NOT NULL)
                                    </code></pre>
                                    <span id="sql_not_in"></span>
                                    <aside class="notes">Oben: Hersteller, von denen es Produkte gibt; unten: Hersteller, von denen es keine Produkte gibt. Würde man unten das <code>WHERE hersteller IS NOT NULL</code> weglassen, würden in der Sub-Anfrage NULL-Werte auftauchen und das Ergebnis der Anfrage wäre leer. Berechnungen und Vergleiche mit NULL-Werten liefern stets NULL, was bei Prädikatsauswertungen immer mit FALSE gedeutet wird.</code></aside>
                                </section>

                                <section>
                                    <h2>CAST: Typumwandlung</h2>
                                    <div class="trackinfo"><i class="fas fa-headphones"></i> 80</div>
                                    <h4><code>CAST(ausdruck AS datentyp)</code></h4>
                                    <pre><code class="sql" data-trim contenteditable>
SELECT preis, CAST(preis AS INT), CAST(preis AS VARCHAR(50))
FROM produkte
                                    </code></pre>
                                    <span class="sqlresult"></span>
                                    <aside class="notes">Unsere Preis-Spalte hat den Datentyp DECIMAL(9,2). Wenn wir die Werte dieser Spalte in INTEGER umwandeln, werden die Nachkommastellen verworfen. Casten wir auf VARCHAR, sehen wir im Ergebnis keinen Unterschied, allerdings liegen unsere Preise nun als Strings und nicht mehr als Zahl vor.</aside>
                                </section>

                                <section>
                                    <h2>CASE WHEN</h2>
                                    <div class="trackinfo"><i class="fas fa-headphones"></i> 81</div>
                                    <h4><code>CASE WHEN ... THEN ... ELSE ... END</code></h4>
                                    <pre><code class="sql" data-trim contenteditable>
SELECT bezeichnung, preis, 
CASE WHEN preis < 1 THEN 'billig' 
     WHEN preis < 5 THEN 'mittel' 
     ELSE 'teuer' END
FROM produkte
                                    </code></pre>
                                    <span class="sqlresult"></span>
                                    <aside class="notes">Wenn die erste Bedingung nicht erfüllt ist, wird die zweite überprüft, usw.</aside>
                                </section>

                                <section>
                                        <h2>CASE WHEN</h2>
                                        <h4><code>CASE ... WHEN ... THEN ... ELSE ... END</code></h4>
                                        <pre><code class="sql" data-trim contenteditable>
    SELECT bezeichnung, preis, 
    CASE preis WHEN 0 THEN 'kostenlos' ELSE preis END
    FROM produkte ORDER BY preis
                                        </code></pre>
                                        <span class="sqlresult"></span>
                                        <aside class="notes">Steht zwischen CASE und WHEN ein Ausdruck, kann man diesen Ausdruck ohne viel Schreibarbeit auf verschiedene Werte überprüfen. Der hier stehende Ausdruck ist äquivalent zu <code>CASE WHEN preis = 0 THEN 'kostenlos' ELSE preis END</code></aside>
                                    </section>

                                <section>
                                    <h2>Dummy-Tabelle DUAL</h2>
                                    <div class="trackinfo"><i class="fas fa-headphones"></i> 81</div>
                                    <p class="class">In einigen DBMS (Oracle, DB2, ...) gibt es die Tabelle DUAL.</p>
                                    <pre><code class="sql dont_execute_sql" data-trim contenteditable>SELECT * FROM dual</code></pre>
                                    <span data-sql-query="select null as dummy"></span>

                                    <p class="small">Praktisch zum Rechnen und Ausprobieren von Funktionen:</p>
                                    <pre><code class="sql dont_execute_sql" data-trim contenteditable>SELECT 5*3, CASE WHEN 7>4 THEN 'Ja' ELSE 'Nein' END FROM DUAL</code></pre>
                                    <span data-sql-query="SELECT 5*3, CASE WHEN 7>4 THEN 'Ja' ELSE 'Nein' END"></span>
                                </section>

                                <section>
                                    <h3>SELECT ohne FROM in PostgreSQL</h3>
                                    <pre><code class="sql" data-trim contenteditable>SELECT 5*3, CASE WHEN 7>4 THEN 'Ja' ELSE 'Nein' END</code></pre>
                                    <span class="sqlresult"></span>

                                    <div class="fragment">
                                    <p class="small">Wie viele Tage sind noch bis Weihnachten?</p>
                                    <pre><code class="sql dont_execute_sql" data-trim contenteditable>SELECT DATE '2020-12-25' - CURRENT_DATE</code></pre>
                                    </div>

                                    <div class="poll fragment" style="bottom:-280px">
                                        <h1>Wie kann man den Spalten dieser Anfrage sinnvolle Namen geben?</h1>
                                            <ul>
                                                <li data-poll="correct">SELECT DATE '2020-12-25' - CURRENT_DATE anzahl_tage</li>
                                                <li>SELECT DATE '2020-12-25' - CURRENT_DATE : anzahl_tage</li>
                                                <li data-poll="correct">SELECT DATE '2020-12-25' - CURRENT_DATE AS anzahl_tage</li>
                                                <li>RENAME column DATE '2020-12-25' - CURRENT_DATE AS anzahl_tage</li>
                                            </ul>
                                        <h2>https://fraage.de</h2>
                                    </div>

                                    <aside class="notes">PostgreSQL erlaubt SELECT-Anfragen ohne FROM-Klausel. Dies entspricht Anfragen auf der DUAL-Tabelle von der vorherigen Folie. Man kann mit solchen Anfragen leicht Funktionen aufrufen und ausprobieren oder Berechnungen durchführen.</aside>
                                </section>

                                <section>
                                        <h2>Kapitelzusammenfassung</h2>
                                        <ul class="small">
                                            <li>SQL: Anfragesprache für strukturierte Datenbanken</li>
                                            <li>DDL: CREATE / ALTER / DROP TABLE</li>
                                            <li>Datentypen: INT, VARCHAR, CHAR, DECIMAL, DATE, ...</li>
                                            <li>Constraints: PRIMARY KEY, NOT NULL, CHECK, UNIQUE, ...</li>
                                            <li data-hide-from="2V">Referentielle Aktionen: ON DELETE/UPDATE ...</li>
                                            <li>DML: INSERT, UPDATE, DELETE, TRUNCATE, SELECT</li>
                                            <li>SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT</li>
                                            <li>[LEFT/RIGHT/FULL] JOIN ON ...</li>
                                            <li>Aggregatfunktionen: COUNT, SUM, AVG, MIN, MAX</li>
                                            <li>Subanfragen, CTEs, EXISTS, IN</li>
                                            <li>Mengenoperationen: UNION / INTERSECT / EXCEPT [ALL]</li>
                                        </ul>
                                    </section>

                        </div>
                    </div>
            
                    <script src="reveal.js/dist/reveal.js"></script>
		<script src="reveal.js/plugin/markdown/markdown.js"></script>
		<script src="reveal.js/plugin/highlight/highlight.js"></script>
		<script src="reveal.js/plugin/zoom/zoom.js"></script>
		<script src="reveal.js/plugin/math/math.js"></script>
		<script src="reveal.js/plugin/notes/notes.js"></script>
		<script src="reveal.js/plugin/search/search.js"></script>
        <script src="lib/jquery.js"></script>
        <script src="lib/lodash.js"></script>
        <script src="lib/backbone.js"></script>
        <script src="lib/joint.min.js"></script>
        <script src="lib/deflate.js"></script>

		<script src="src/init_reveal.js"></script>

        <script>
        if(window.location.search.match( /print-pdf/gi )) {
                document.getElementById('header').style="display:none";
                document.getElementById('footer').style="display:none";
        }
        </script>


	</body>
</html>